"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.buildProject = exports.buildAppPackage = exports.buildCompanion = exports.buildDeviceComponents = exports.buildDeviceResources = exports.buildComponent = exports.loadProjectConfig = exports.generateBuildId = exports.DiagnosticCategory = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const stream_1 = require("stream");
const drop_stream_1 = tslib_1.__importDefault(require("drop-stream"));
const lazystream_1 = tslib_1.__importDefault(require("lazystream"));
const merge_stream_1 = tslib_1.__importDefault(require("merge-stream"));
const multistream_1 = tslib_1.__importDefault(require("multistream"));
const playback_stream_1 = tslib_1.__importDefault(require("playback-stream"));
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const pumpify_1 = tslib_1.__importDefault(require("pumpify"));
const simple_random_1 = tslib_1.__importDefault(require("simple-random"));
const vinyl_fs_1 = tslib_1.__importDefault(require("vinyl-fs"));
const appPackageManifest_1 = tslib_1.__importDefault(require("./appPackageManifest"));
const BuildError_1 = tslib_1.__importDefault(require("./util/BuildError"));
const buildTargets_1 = tslib_1.__importDefault(require("./buildTargets"));
const collectComponentSourceMaps_1 = tslib_1.__importDefault(require("./collectComponentSourceMaps"));
const compile_1 = tslib_1.__importDefault(require("./compile"));
const compileTranslations_1 = tslib_1.__importDefault(require("./compileTranslations"));
const componentManifest_1 = require("./componentManifest");
const componentTargets_1 = tslib_1.__importStar(require("./componentTargets"));
const convertImageToTXI_1 = tslib_1.__importStar(require("./convertImageToTXI"));
const eventsIntercept_1 = tslib_1.__importDefault(require("./util/eventsIntercept"));
const gulpAssertFiles_1 = tslib_1.__importDefault(require("./gulpAssertFiles"));
const gulpSetProperty_1 = tslib_1.__importDefault(require("./gulpSetProperty"));
const diagnostics_1 = require("./diagnostics");
Object.defineProperty(exports, "DiagnosticCategory", { enumerable: true, get: function () { return diagnostics_1.DiagnosticCategory; } });
const filterResourceTag_1 = tslib_1.__importDefault(require("./filterResourceTag"));
const findEntryPoint_1 = tslib_1.__importDefault(require("./findEntryPoint"));
const nativeComponents_1 = tslib_1.__importDefault(require("./nativeComponents"));
const pluginError_1 = tslib_1.__importDefault(require("./util/pluginError"));
const ProjectConfiguration_1 = require("./ProjectConfiguration");
const resources = tslib_1.__importStar(require("./resources"));
const validateIcon_1 = tslib_1.__importDefault(require("./validateIcon"));
const validateFileSizes_1 = tslib_1.__importDefault(require("./validateFileSizes"));
const zip_1 = tslib_1.__importDefault(require("./zip"));
function generateBuildId() {
    return `0x0${simple_random_1.default({
        secure: simple_random_1.default.isSecureSupported,
        chars: '0123456789abcdef',
        length: 15,
    })}`;
}
exports.generateBuildId = generateBuildId;
function addDiagnosticTarget(target, onDiagnostic) {
    return (diagnostic) => onDiagnostic(Object.assign({ target }, diagnostic));
}
function addErrorTarget(target, fn) {
    function wrap(err) {
        if (BuildError_1.default.is(err) || pluginError_1.default.isPluginError(err)) {
            err.target = target;
        }
        return err;
    }
    try {
        const buildStream = eventsIntercept_1.default(fn());
        buildStream.intercept('error', (err, done) => done(null, wrap(err)));
        return buildStream;
    }
    catch (ex) {
        throw wrap(ex);
    }
}
function lazyObjectReadable(fn) {
    const lazyStream = new lazystream_1.default.Readable(() => {
        try {
            return fn();
        }
        catch (ex) {
            lazyStream.emit('error', ex);
            return emptyReadable();
        }
    }, { objectMode: true });
    return lazyStream;
}
function emptyReadable() {
    return new stream_1.Readable({
        objectMode: true,
        read() {
            this.push(null);
        },
    });
}
function transformIf(condition, plugin) {
    return condition ? plugin : new stream_1.Stream.PassThrough({ objectMode: true });
}
function loadProjectConfig({ hasNativeComponents = false, onDiagnostic = diagnostics_1.logDiagnosticToConsole, fileName = 'package.json', }) {
    try {
        const config = ProjectConfiguration_1.normalizeProjectConfig(JSON.parse(fs_1.default.readFileSync(fileName, 'utf-8')));
        const diagnostics = ProjectConfiguration_1.validate(config, { hasNativeComponents });
        diagnostics.diagnostics.forEach((diagnostic) => onDiagnostic(Object.assign({ file: { path: fileName } }, diagnostic)));
        if (diagnostics.fatalError) {
            throw new BuildError_1.default('Project configuration is invalid');
        }
        if (config.enableProposedAPI) {
            onDiagnostic({
                category: diagnostics_1.DiagnosticCategory.Warning,
                messageText: 'Targeting proposed API may cause your app to behave unexpectedly. Use only when needed for development or QA.',
            });
        }
        return config;
    }
    catch (err) {
        throw new plugin_error_1.default('projectConfig', err, { fileName });
    }
}
exports.loadProjectConfig = loadProjectConfig;
function buildComponent({ projectConfig, component, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const { inputs, outputDir, notFoundIsFatal } = componentTargets_1.default[component];
    const entryPoint = findEntryPoint_1.default(inputs, {
        onDiagnostic,
        component,
        notFoundIsFatal,
    });
    if (!entryPoint)
        return;
    return lazyObjectReadable(() => new pumpify_1.default.obj(compile_1.default({
        component,
        onDiagnostic,
        entryPoint,
        outputDir,
        allowUnknownExternals: projectConfig.enableProposedAPI,
        defaultLanguage: projectConfig.defaultLanguage,
    }), gulpSetProperty_1.default({
        componentType: component,
    })));
}
exports.buildComponent = buildComponent;
function buildDeviceResources(projectConfig, { resourceFilterTag }, onDiagnostic = diagnostics_1.logDiagnosticToConsole) {
    return new pumpify_1.default.obj(filterResourceTag_1.default(resourceFilterTag), validateIcon_1.default({ projectConfig, onDiagnostic }), convertImageToTXI_1.default({
        rgbaOutputFormat: convertImageToTXI_1.TXIOutputFormat.RGBA6666,
    }), gulpAssertFiles_1.default([resources.svgMain, resources.svgWidgets]));
}
exports.buildDeviceResources = buildDeviceResources;
function buildDeviceComponents({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const deviceJSPipeline = [
        buildComponent({
            projectConfig,
            onDiagnostic,
            component: componentTargets_1.ComponentType.DEVICE,
        }),
    ];
    const processedJS = new playback_stream_1.default({ objectMode: true });
    deviceJSPipeline.push(processedJS);
    return multistream_1.default.obj([
        new pumpify_1.default.obj(...deviceJSPipeline, drop_stream_1.default.obj()),
        ...projectConfig.buildTargets.map((family) => lazyObjectReadable(() => {
            const { platform, displayName, maxDeviceBundleSize } = buildTargets_1.default[family];
            onDiagnostic({
                messageText: `Building app for ${displayName}`,
                category: diagnostics_1.DiagnosticCategory.Message,
            });
            const bundleFilename = `device-${family}.zip`;
            const sourceMap = collectComponentSourceMaps_1.default();
            return new pumpify_1.default.obj(merge_stream_1.default(new pumpify_1.default.obj(processedJS.newReadableSide({ objectMode: true }), sourceMap.collector(componentTargets_1.ComponentType.DEVICE, family)), new pumpify_1.default.obj(vinyl_fs_1.default.src('./resources/**', { base: '.' }), buildDeviceResources(projectConfig, buildTargets_1.default[family], onDiagnostic)), new pumpify_1.default.obj(vinyl_fs_1.default.src(componentTargets_1.default.device.translationsGlob, {
                base: '.',
            }), compileTranslations_1.default(projectConfig.defaultLanguage))), componentManifest_1.makeDeviceManifest({ projectConfig, buildId, targetDevice: family }), zip_1.default(bundleFilename), transformIf(maxDeviceBundleSize !== undefined, validateFileSizes_1.default({
                onDiagnostic,
                maxSizes: { [bundleFilename]: maxDeviceBundleSize },
            })), gulpSetProperty_1.default({
                componentBundle: {
                    family,
                    platform,
                    type: 'device',
                },
            }), sourceMap.emitter);
        })),
    ]);
}
exports.buildDeviceComponents = buildDeviceComponents;
function buildCompanion({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const sourceMaps = collectComponentSourceMaps_1.default();
    const diagnosticTargets = {
        [componentTargets_1.ComponentType.COMPANION]: diagnostics_1.DiagnosticTarget.Companion,
        [componentTargets_1.ComponentType.SETTINGS]: diagnostics_1.DiagnosticTarget.Settings,
        [componentTargets_1.ComponentType.DEVICE]: diagnostics_1.DiagnosticTarget.App,
    };
    const [companion, settings] = [
        componentTargets_1.ComponentType.COMPANION,
        componentTargets_1.ComponentType.SETTINGS,
    ].map((componentType) => {
        const targetedDiagnostic = addDiagnosticTarget(diagnosticTargets[componentType], onDiagnostic);
        const component = buildComponent({
            projectConfig,
            component: componentType,
            onDiagnostic: targetedDiagnostic,
        });
        if (component) {
            return lazyObjectReadable(() => {
                targetedDiagnostic({
                    category: diagnostics_1.DiagnosticCategory.Message,
                    messageText: `Building ${diagnosticTargets[componentType]}`,
                });
                return new pumpify_1.default.obj(addErrorTarget(diagnosticTargets[componentType], () => component), sourceMaps.collector(componentType));
            });
        }
        return component;
    });
    if (settings && !companion) {
        throw new BuildError_1.default('This project is being built with settings, but has no companion component.');
    }
    const components = [companion, settings].filter((component) => component !== undefined);
    if (components.length === 0)
        return;
    return lazyObjectReadable(() => new pumpify_1.default.obj(multistream_1.default.obj(components), componentManifest_1.makeCompanionManifest({
        projectConfig,
        buildId,
        hasSettings: !!settings,
    }), zip_1.default('companion.zip'), gulpSetProperty_1.default({
        componentBundle: { type: 'companion' },
    }), sourceMaps.emitter));
}
exports.buildCompanion = buildCompanion;
function buildAppPackage({ projectConfig, buildId, existingDeviceComponents, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const components = [];
    if (existingDeviceComponents) {
        onDiagnostic({
            messageText: 'Bundling native device components, JS device app will not be built',
            category: diagnostics_1.DiagnosticCategory.Message,
        });
        components.push(existingDeviceComponents);
    }
    else {
        components.push(addErrorTarget(diagnostics_1.DiagnosticTarget.App, () => buildDeviceComponents({
            projectConfig,
            buildId,
            onDiagnostic: addDiagnosticTarget(diagnostics_1.DiagnosticTarget.App, onDiagnostic),
        })));
    }
    const companion = buildCompanion({
        projectConfig,
        buildId,
        onDiagnostic: addDiagnosticTarget(diagnostics_1.DiagnosticTarget.Companion, onDiagnostic),
    });
    if (companion)
        components.push(companion);
    return new pumpify_1.default.obj(multistream_1.default.obj(components), appPackageManifest_1.default({
        projectConfig,
        buildId,
    }), zip_1.default('app.fba'));
}
exports.buildAppPackage = buildAppPackage;
function buildProject({ nativeDeviceComponentPaths = [], onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    let buildId;
    let existingDeviceComponents;
    const projectConfig = loadProjectConfig({
        onDiagnostic,
        hasNativeComponents: nativeDeviceComponentPaths && nativeDeviceComponentPaths.length > 0,
    });
    if (nativeDeviceComponentPaths.length > 0) {
        ({ buildId, existingDeviceComponents } = nativeComponents_1.default(projectConfig.appUUID, nativeDeviceComponentPaths));
    }
    else {
        buildId = generateBuildId();
    }
    return buildAppPackage({
        projectConfig,
        buildId,
        onDiagnostic,
        existingDeviceComponents,
    }).on('finish', () => {
        onDiagnostic({
            messageText: `App UUID: ${projectConfig.appUUID}, BuildID: ${buildId}`,
            category: diagnostics_1.DiagnosticCategory.Message,
        });
    });
}
exports.buildProject = buildProject;
function build({ dest = vinyl_fs_1.default.dest('./build'), onDiagnostic = diagnostics_1.logDiagnosticToConsole, nativeDeviceComponentPaths, } = {}) {
    return new Promise((resolve, reject) => {
        new pumpify_1.default.obj(buildProject({ nativeDeviceComponentPaths, onDiagnostic }), dest)
            .on('error', reject)
            .on('finish', resolve);
    }).catch((e) => {
        if (pluginError_1.default.isPluginError(e) && pluginError_1.default.isProjectBuildError(e)) {
            onDiagnostic(pluginError_1.default.convertToDiagnostic(e));
            return Promise.reject();
        }
        if (BuildError_1.default.is(e)) {
            onDiagnostic(e.toDiagnostic());
            return Promise.reject();
        }
        return Promise.reject(e);
    });
}
exports.build = build;
